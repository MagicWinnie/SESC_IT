## Линейные списки
**Линейный список** - множество, состоящее из n >= 0 узлов X[1], X[2], ... , X[n], структурные свойства которого ограниченый линейным относительным положением узлов, т.е. следующими условиями:
1) если n > 0, то X[1] - первый узел;
2) если 1 < k < n, то k-му узлу X[k] предшедствует узел X[k - 1], а за узлом X[k] следует узел X[k + 1];

Операции над линейными списками:
1) Получить доступ к k-му элементу списка, изменить значения
2) Включить новый узел перед k-м
3) Удалить k-й узел
4) Объединить два или более линейных списков в один
5) Разбить список на несколько списков
6) Сортировка списка
7) Вычисление длины списка

**Стек** - линейный список, в котором все включения и исключения делаются в одном конце списка.

**Очередь** - линейный список, в котором все включения производятся на одном конце списка, все исключения - на другом его конце.

**Дек (очередь с двумя концами)** - линейный список, в котором все включения и исключения производятся на обоих концах списка.

Операции работы со стеками:
1) ```makenull(S)``` - делает стек S пустым
2) ```create(S)``` - создает стек
3) ```top(S)``` - выдает значение верхнего элемента стека, не удаляя его
4) ```pop(S)``` - выдает значение верхнего элемента стека и удаляет его из стека
5) ```push(x, S)``` - помещает в стек S новый элемент со значением x
6) ```empty(S)``` - проверка на пустоту стека  

```cpp
struct list
{
    int data;
    struct list *next;
};
typedef struct stack { struct list *top; } Stack;

void makenull(Stack *S)
{
    struct list *p;
    while (S->top)
    {
        p = S->top;
        S->top = p->next;
        free(p);
    }
}
Stack *create()
{
    Stack *S;
    S = (Stack *)malloc(sizeof(Stack));
    S->top = NULL;
    return S;
}
int top(Stack *S)
{
    if (S->top)
        return (S->top->data);
    else
        return 0; // or raise an error, 'cause the stack is empty  
}
int pop(Stack *S)
{
    int a;
    struct list *p;
    p = S->top;
    a = p->data;
    S->top = p->next;
    free(p);
    return a;
}
void push(int a, Stack *S)
{
    struct list *p;
    p = (struct list *)malloc(sizeof(struct list));
    p->data = a;
    p->next = S->top;
    S->top = p;
}
int empty(Stack *S)
{
    return (S->top == NULL);
}
```
## Виды записи выражений:  
* Префиксная (операция перед операндами)  
* Инфиксная или скобочная (операция между операндами)  
* Постфиксная или обратная польская (операция после операндов)  

#### Примеры:
* Инфиксная:  
    `a + (f - b * c / (z - x) + y) / (a * r - k)`  
* Префиксная:  
    `+ a / + - f / * b c - z x y - * a r k`  
* Постфиксная:  
    `a f b c * z x - / - y + a r * k - / +`  
### Перевод из инфиксной формы в постфиксную  
*Вход*: строка, содержащая арифметическое выражение, записанное в инфиксной форме.  
*Выход*: строка, содержащая то же выражение, записанное в постфиксной форме (обратной польской записи).  
*Обозначения*: числа, строки (индентификаторы) - операнды;  
| Знаки операций | Приоритеты |  
| :---: | :---: |  
| ( | 1 |  
| ) | 2 |  
| = | 3 |  
| +, - | 4 |
| *, / | 5 |

### Алгоритм  
0. Взять первый элемент из входной строки и поместить его в `X`. Выходная строка и стек пусты.
1. Если `X` - операнд, то дописать его в конце выходной строки.  
Если `X` = `(`, то поместить его в стек.  
Если `X` = `)`, то вытолкнуть из стека и поместить в конец выходной строки все элементы до первой встреченной открывающей скобки. Эту скобку вытолкнуть из стека.  
Если `X` - знак операции, отличный от скобок, то пока стек не пуст, и верхний элемент стека имеет приоритет, больший либо равный приоритету `X`, вытолкнуть его из стека и поместить в выходную строку. Затем поместить `X` в стек.  
2. Если входная строка не исчерпана, то поместить в `X` очередной элемент входной строки и перейти на шаг 1., иначе пока стек не пуст, вытолкнуть из стека содержимое в выходную строку.  

#### Пример  
*Входная строка*:  
`a + (f - b * c / (z - x) + y) / (a * r - k)`  
*Выходная строка*:  
`a f b c * z x - / - y + a r * k - / +`    